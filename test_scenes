#!/usr/bin/env bash

get_scenes(){
	find scenes -type f
}

fatal(){
	printf "[FATAL]: %s\n" "${1}"
	exit ${2}
}

usage(){
	printf -- "${opt_str[generic]}"
	exit ${1}
}

help(){
	case "${1}" in
		(v | verbose)
			printf -- "${opt_str[v]}"
			exit 0
			;;
		(b | binary)
			printf -- "${opt_str[b]}"
			exit 0
			;;
		(g | n | grayscale | no-color)
			printf -- "${opt_str[g]}"
			exit 0
			;;
		(h | help)
			printf -- "${opt_str[h]}"
			exit 0
			;;
		(all)
			printf -- "${opt_str["generic"]}"
			for s in "${opt_str[@]}"; do
				if [ "${s}" != "${opt_str["generic"]}" ]; then
					printf -- "\n${s}"
				fi
			done
			exit 0
		(*)
			printf "%s is not an option\n" "${1}"
			exit 1
			;;
	esac
}

get_options(){
	local -A opt_str
	local binname=$0
	opt_str["v"]="\t-v | --verbose\n\t\tprints all tests, even ones that pass\n"
	opt_str["b"]="\t-b<file> | --binary=<file>\n\t\tspecify what binary to test the .rt scenes with (default: \"./minirt\")\n"
	opt_str["g"]="\t-g | --grayscale\n\t-n | --no-color\n\t\tturn off colored outputs\n"
	opt_str["h"]="\t-h[opt] | --help=[opt]\n\t\tdisplay usage and available options\n\t\tif [opt] is provided, instead display detailed option description\n"
	opt_str["generic"]="Usage: ${binname} [-b<file> | --binary <file>] [-v | --verbose] [-g | --grayscale | -n | --no-color] [-h[opt] | --help [opt]]\n"
	local args
	args=`getopt -u --options "b:vngh::" --longoptions "binary:,verbose,grayscale,no-color,help::,valgrind" -- "${@}"` || fatal "invalid option" 1
	eval "set -- ${args}"

	while :
	do
		case "${1}" in
			(-v | --verbose)
				verbose=true
				shift
				;;
			(-b | --binary)
				binary="${2}"
				shift 2
				;;
			(-g | --grayscale | -n | --no-color)
				color=false
				shift
				;;
			(-h | --help)
				if [ -n ${2} ]; then help ${2}; fi
				usage 0
				;;
			(--valgrind)
				valgrind=valgrind
				shift
				;;
			(--)
				shift
				break
				;;
			(*)
				usage 1
				;;
		esac
	done
}

default(){
	# unconditional
	BOLD=`tput bold`
	RED=`tput setaf 1`
	GREEN=`tput setaf 2`
	OFF=`tput sgr0`

	# could be changed by user
	verbose=${verbose:=false}
	binary=${binary:="./minirt"}
	color=${color:=true}
	if [ ${color} = true ]; then
		fail_string="${RED}${BOLD}[FAIL]${OFF}"
		pass_string="${GREEN}${BOLD}[PASS]${OFF}"
	else
		fail_string="[FAIL]"
		pass_string="[PASS]"
	fi
	all_pass=${pass_string}
}

expect_error(){
	if ${binary} ${scene} >/dev/null 2>/dev/null; then
		err=${fail_string}
		all_pass=${err}
	else
		err=${pass_string}
	fi
}

expect_success(){
	if ${binary} ${scene} >/dev/null; then
		err=${pass_string}
	else
		err=${fail_string}
		all_pass=${err}
	fi
}

expect_valgrind(){
	local leak="${fail_string%%FAIL*}LEAK${fail_string##*FAIL}"
	local ret

	${valgrind} --error-exitcode=66 ${binary} ${scene} >/dev/null 2>/dev/null
	ret=$?
	if [ ${ret} = 66 ]; then
		err=${leak}
	elif echo ${scene} | grep "error" >/dev/null; then
		if [ ${ret} > 0 ]; then err=${pass_string}; else err=${fail_string}; fi
	else
		if [ ${ret} = 0 ]; then err=${pass_string}; else err=${fail_string}; fi
	fi
	if [ ${err} != ${pass_string} ]; then all_pass=${err}; fi
}

main(){
	local -a scenes=(`get_scenes`)
	local scene err all_pass i
	# options
	local verbose binary valgrind color
	# visual
	local fail_string pass_string RED GREEN BOLD OFF

	get_options $@
	default
	which ${binary} >/dev/null 2>/dev/null || fatal "${binary} does not exist" 1

	printf "%s[BEGIN]%s\n" "${BOLD}" "${OFF}"
	for scene in ${scenes[@]};
	do
		((i++))
		if [ ${valgrind} ]; then
			expect_valgrind
		elif echo ${scene} | grep "error" >/dev/null; then
			expect_error
		else
			expect_success
		fi
		if [[ ${err} == ${fail_string} || ${verbose} == true ]];
		then
			[[ "${scene}" =~ scenes/(error/)?(.*) ]] && printf "%s[%2d/%2d]%s %s %s\n" "${BOLD}" "${i}" "${#scenes[@]}" "${OFF}" "${err}" "${BASH_REMATCH[2]}"
		elif [ "${all_pass}" = "${pass_string}" ]; then
			if [ ${i} != 1 ]; then printf "\033[A"; fi
			printf "\033[G%s[%2d/%2d]%s\n" "${BOLD}" "${i}" "${#scenes[@]}" "${OFF}"
		fi
	done
	printf "%s[FINAL]%s %s\n" "${BOLD}" "${OFF}" "${all_pass}"
	if [ "${all_pass}" = "${pass_string}" ]; then
		return 0
	fi
	return 1
}

main $@
